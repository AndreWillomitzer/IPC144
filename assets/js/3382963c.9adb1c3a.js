(self.webpackChunkipc_144=self.webpackChunkipc_144||[]).push([[9483],{3905:function(t,e,a){"use strict";a.d(e,{Zo:function(){return m},kt:function(){return c}});var n=a(7294);function r(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function i(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function o(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?i(Object(a),!0).forEach((function(e){r(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function s(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},i=Object.keys(t);for(n=0;n<i.length;n++)a=i[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(n=0;n<i.length;n++)a=i[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}var l=n.createContext({}),d=function(t){var e=n.useContext(l),a=e;return t&&(a="function"==typeof t?t(e):o(o({},e),t)),a},m=function(t){var e=d(t.components);return n.createElement(l.Provider,{value:e},t.children)},u={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},p=n.forwardRef((function(t,e){var a=t.components,r=t.mdxType,i=t.originalType,l=t.parentName,m=s(t,["components","mdxType","originalType","parentName"]),p=d(a),c=r,f=p["".concat(l,".").concat(c)]||p[c]||u[c]||i;return a?n.createElement(f,o(o({ref:e},m),{},{components:a})):n.createElement(f,o({ref:e},m))}));function c(t,e){var a=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var i=a.length,o=new Array(i);o[0]=p;var s={};for(var l in e)hasOwnProperty.call(e,l)&&(s[l]=e[l]);s.originalType=t,s.mdxType="string"==typeof t?t:r,o[1]=s;for(var d=2;d<i;d++)o[d]=a[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},6721:function(t,e,a){"use strict";a.r(e),a.d(e,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return d},toc:function(){return m},default:function(){return p}});var n=a(2122),r=a(9756),i=(a(7294),a(3905)),o=["components"],s={sidebar_position:2},l="Information",d={unversionedId:"A-Introduction/information",id:"A-Introduction/information",isDocsHomePage:!1,title:"Information",description:"Learning Outcomes",source:"@site/docs/A-Introduction/information.md",sourceDirName:"A-Introduction",slug:"/A-Introduction/information",permalink:"/A-Introduction/information",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/A-Introduction/information.md",version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"courseNotesSidebar",previous:{title:"Computers",permalink:"/A-Introduction/computers"},next:{title:"Compilers",permalink:"/A-Introduction/compilers"}},m=[{value:"Learning Outcomes",id:"learning-outcomes",children:[]},{value:"Introduction",id:"introduction",children:[]},{value:"Fundamental Units",id:"fundamental-units",children:[]},{value:"Memory Model",id:"memory-model",children:[]},{value:"Addresses",id:"addresses",children:[]},{value:"Sets of Bytes",id:"sets-of-bytes",children:[]},{value:"Limit on Addressability (Optional)",id:"limit-on-addressability-optional",children:[]},{value:"Segmentation Faults",id:"segmentation-faults",children:[]}],u={toc:m};function p(t){var e=t.components,s=(0,r.Z)(t,o);return(0,i.kt)("wrapper",(0,n.Z)({},u,s,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"information"},"Information"),(0,i.kt)("h3",{id:"learning-outcomes"},"Learning Outcomes"),(0,i.kt)("p",null,"After reading this section, you will be able to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Define the units for storing information on a modern computer"),(0,i.kt)("li",{parentName:"ul"},"Introduce the memory model for programming a modern computer"),(0,i.kt)("li",{parentName:"ul"},"Introduce the addressing system for accessing the memory of a modern computer")),(0,i.kt)("h3",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"The information stored in a computer includes program instructions and program data.  This information is stored in bits in RAM.  The instructions and data take the form of groups of bits.  The two most common systems for interpreting information stored in RAM are the binary and hexadecimal numbering systems. "),(0,i.kt)("p",null,"This chapter defines these numbering systems and their units and describes the memory model for addressing different groups of bits stored in the part of RAM associated with a program."),(0,i.kt)("h3",{id:"fundamental-units"},"Fundamental Units"),(0,i.kt)("h4",{id:"bits"},"Bits"),(0,i.kt)("p",null,"The most fundamental unit of a modern computer is the binary digit or bit.  A bit is either on or off.  One ","(","1",")"," represents on, while zero ","(","0",")"," represents off. "),(0,i.kt)("p",null,"Since bits are too numerous to handle individually, modern computers transfer and handle information in larger units.  As programmers, we define some of those units. "),(0,i.kt)("h4",{id:"bytes"},"Bytes"),(0,i.kt)("p",null,"The fundamental addressable unit of RAM is the byte.  One byte consists of 2 nibbles.  Each nibble consists of 4 bits."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Byte, nibble, and bit breakdown illustration",src:a(3897).Z})),(0,i.kt)("p",null,"One byte can store any one of 256 ","(","28",")"," possible values in the form of a bit string: "),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"Bit Value"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Decimal Value"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"00000000"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"00000001"),(0,i.kt)("td",{parentName:"tr",align:"left"},"1")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"00000010"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"00000011"),(0,i.kt)("td",{parentName:"tr",align:"left"},"3")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"00000100"),(0,i.kt)("td",{parentName:"tr",align:"left"},"4")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"..."),(0,i.kt)("td",{parentName:"tr",align:"left"},"...")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"00111000"),(0,i.kt)("td",{parentName:"tr",align:"left"},"56")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"..."),(0,i.kt)("td",{parentName:"tr",align:"left"},"...")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"11111111"),(0,i.kt)("td",{parentName:"tr",align:"left"},"255")))),(0,i.kt)("p",null,"The bit strings are on the left.  The equivalent decimal values are on the right.  Note that our counting system starts from 0, not from 1."),(0,i.kt)("h4",{id:"words"},"Words"),(0,i.kt)("p",null,"We call the natural size of the execution environment a word. A word consists of an integral number of bytes and is typically the size of the CPU's general registers. Word size may vary from CPU to CPU. On a 16-bit CPU, a word consists of 2 bytes. On a Pentium 4 CPU, the general registers contain 32 bits and a word consists of 4 bytes. On an Itanium 2 CPU, the general registers contain 64 bits, but a word still consists of 4 bytes."),(0,i.kt)("h4",{id:"hexadecimal"},"Hexadecimal"),(0,i.kt)("p",null,"The decimal system is not the most convenient numbering system for organizing information.  The hexadecimal system ","(","base 16",")"," is much more convenient. "),(0,i.kt)("p",null,"Two hexadecimal digits holds the information stored in one byte.  Each digit holds 4 bits of information.  The digit symbols in the hexadecimal number system are {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F}.  The characters A through F denote the values that correspond to the decimal values 10 through 15 respectively.  We use the 0x prefix to identify a number as hexadecimal ","(","rather than decimal - base 10",")","."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"Bit Value"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Hexadecimal Value"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Decimal Value"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"00000000"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0x00"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"00000001"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0x01"),(0,i.kt)("td",{parentName:"tr",align:"left"},"1")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"00000010"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0x02"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"00000011"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0x03"),(0,i.kt)("td",{parentName:"tr",align:"left"},"3")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"00000100"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0x04"),(0,i.kt)("td",{parentName:"tr",align:"left"},"4")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"..."),(0,i.kt)("td",{parentName:"tr",align:"left"},"..."),(0,i.kt)("td",{parentName:"tr",align:"left"})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"00111000"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0x38"),(0,i.kt)("td",{parentName:"tr",align:"left"},"56")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"..."),(0,i.kt)("td",{parentName:"tr",align:"left"},"..."),(0,i.kt)("td",{parentName:"tr",align:"left"})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"11111111"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0xFF"),(0,i.kt)("td",{parentName:"tr",align:"left"},"255")))),(0,i.kt)("p",null,"For example, the hexadecimal value 0x5C is equivalent to the 8-bit value 010111002, which is equivalent to the decimal value 92. "),(0,i.kt)("p",null,"To learn how to convert between hexadecimal and binary refer to the chapter entitled ",(0,i.kt)("a",{parentName:"p",href:"/Resources-Appendices/data-conversions"},"Data Conversions")," in the Appendices."),(0,i.kt)("h3",{id:"memory-model"},"Memory Model"),(0,i.kt)("p",null,"The memory model for organizing information stored in RAM is linear.  Any byte in memory is accessible through a map that treats each actual physical memory location as a position in a continuous sequence of locations aligned next to one another."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://ict.senecacollege.ca//~ipc144/pages/images/ram.png",alt:"RAM memory model: linearly mapped (continuous sequence)"})),(0,i.kt)("h3",{id:"addresses"},"Addresses"),(0,i.kt)("p",null,"Each byte of RAM has a unique address.  Addressing starts at zero, is sequential, and ends at the address equal to the size of RAM less 1 unit. "),(0,i.kt)("p",null,"For example, 4 Gigabytes of RAM"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"consists of 32 ","(","= 4 ","*"," 8",")"," Gigabits"),(0,i.kt)("li",{parentName:"ul"},"starts at a low address of 0x00000000"),(0,i.kt)("li",{parentName:"ul"},"ends at a high address of 0xFFFFFFFF")),(0,i.kt)("p",null,(0,i.kt)("img",{src:a(8271).Z})),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Note")," that each byte, and not each bit, has its own address. We say that RAM is byte-addressable.")),(0,i.kt)("h3",{id:"sets-of-bytes"},"Sets of Bytes"),(0,i.kt)("p",null,"The abbreviations for sets of bytes are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Kilo or k ","(","=1024",")",": 1 Kilobyte = 1024 bytes ~ 103 bytes"),(0,i.kt)("li",{parentName:"ul"},"Mega or M ","(","=1024k",")",": 1 Megabyte = 1024 ","*"," 1024 bytes ~ 106 bytes"),(0,i.kt)("li",{parentName:"ul"},"Giga or G ","(","=1024M",")",": 1 Gigabyte = 1024 ","*"," 1024 ","*"," 1024 bytes ~ 109 bytes"),(0,i.kt)("li",{parentName:"ul"},"Tera or T ","(","=1024G",")",": 1 Terabyte = 1024 ","*"," 1024 ","*"," 1024 ","*"," 1024 bytes ~ 1012 bytes"),(0,i.kt)("li",{parentName:"ul"},"Peta or P ","(","=1024T",")",": 1 Petabyte = 1024 ","*"," 1024 ","*"," 1024 ","*"," 1024 ","*"," 1024 bytes ~ 1015 bytes"),(0,i.kt)("li",{parentName:"ul"},"Exa or E ","(","=1024P",")",": 1 Exabyte = 1024 ","*"," 1024 ","*"," 1024 ","*"," 1024 ","*"," 1024 ","*"," 1024 bytes ~ 1018 bytes")),(0,i.kt)("p",null,"Note that the multiplying factor is 1024, not 1000.  1024 bytes is 210 bytes, which is approximately 103 bytes."),(0,i.kt)("h3",{id:"limit-on-addressability-optional"},"Limit on Addressability ","(","Optional",")"),(0,i.kt)("p",null,"The maximum size of the memory that the CPU can access depends on the size of its address registers.  The highest accessible address is the largest address that an address register can hold: "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"32-bit address registers can address up to 4 GB ","(","Gigabytes",")"," ","(","addresses can range from 0 to 232-1, that is 0 to 4,294,967,295",")",". "),(0,i.kt)("li",{parentName:"ul"},"36-bit address registers can address up to 64 GB ","(","Gigabytes",")"," ","(","addresses can range from 0 to 236-1, that is 0 to 68,719,476,735",")",". "),(0,i.kt)("li",{parentName:"ul"},"64-bit address registers can address up to 16 EB ","(","Exabytes",")"," ","(","addresses can range from 0 to 264-1, that is 0 to 18,446,744,073,709,551,615",")",". ")),(0,i.kt)("h3",{id:"segmentation-faults"},"Segmentation Faults"),(0,i.kt)("p",null,"The information stored in RAM consists of information that serves different purposes. We expect to read and write data, but not to execute it. We expect to execute program instructions but not to write them. So, certain architectures assign the data read and write permissions, while assigning instructions read and execute permissions. Such permission system helps trap errors while a program is executing. An attempt to execute data or to overwrite an instruction reports an error. Clearly, the access has been to the wrong segment. We call such errors a segmentation faults."))}p.isMDXComponent=!0},3897:function(t,e,a){"use strict";e.Z=a.p+"assets/images/bytenibbit-07ecd6ebcd709b1c68b3165fc4eb7b70.jpg"},8271:function(t,e,a){"use strict";e.Z=a.p+"assets/images/image21-c93c5084abf036eda1ad8eb8c2aadadc.png"}}]);